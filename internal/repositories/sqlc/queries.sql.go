// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package catalogsql

import (
	"context"

	po "github.com/bionicotaku/lingo-services-profile/internal/models/po"
	uuid "github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const findPublishedVideo = `-- name: FindPublishedVideo :one
SELECT
    video_id,
    title,
    status,
    media_status,
    analysis_status,
    visibility_status,
    publish_at,
    created_at,
    updated_at
FROM catalog.videos
WHERE video_id = $1
  AND status IN ('ready', 'published')
`

type FindPublishedVideoRow struct {
	VideoID          uuid.UUID          `json:"video_id"`
	Title            string             `json:"title"`
	Status           po.VideoStatus     `json:"status"`
	MediaStatus      po.StageStatus     `json:"media_status"`
	AnalysisStatus   po.StageStatus     `json:"analysis_status"`
	VisibilityStatus string             `json:"visibility_status"`
	PublishAt        pgtype.Timestamptz `json:"publish_at"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
}

// 读取前台查询可见的视频（仅 ready/published），字段裁剪
func (q *Queries) FindPublishedVideo(ctx context.Context, videoID uuid.UUID) (FindPublishedVideoRow, error) {
	row := q.db.QueryRow(ctx, findPublishedVideo, videoID)
	var i FindPublishedVideoRow
	err := row.Scan(
		&i.VideoID,
		&i.Title,
		&i.Status,
		&i.MediaStatus,
		&i.AnalysisStatus,
		&i.VisibilityStatus,
		&i.PublishAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getVideoLifecycleSnapshot = `-- name: GetVideoLifecycleSnapshot :one
SELECT
    video_id,
    upload_user_id,
    created_at,
    updated_at,
    title,
    description,
    raw_file_reference,
    status,
    version,
    media_status,
    analysis_status,
    media_job_id,
    media_emitted_at,
    analysis_job_id,
    analysis_emitted_at,
    raw_file_size,
    raw_resolution,
    raw_bitrate,
    duration_micros,
    encoded_resolution,
    encoded_bitrate,
    thumbnail_url,
    hls_master_playlist,
    difficulty,
    summary,
    tags,
    visibility_status,
    publish_at,
    raw_subtitle_url,
    error_message
FROM catalog.videos
WHERE video_id = $1
`

// 读取生命周期写流程所需的完整快照，无状态限制
func (q *Queries) GetVideoLifecycleSnapshot(ctx context.Context, videoID uuid.UUID) (CatalogVideo, error) {
	row := q.db.QueryRow(ctx, getVideoLifecycleSnapshot, videoID)
	var i CatalogVideo
	err := row.Scan(
		&i.VideoID,
		&i.UploadUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Title,
		&i.Description,
		&i.RawFileReference,
		&i.Status,
		&i.Version,
		&i.MediaStatus,
		&i.AnalysisStatus,
		&i.MediaJobID,
		&i.MediaEmittedAt,
		&i.AnalysisJobID,
		&i.AnalysisEmittedAt,
		&i.RawFileSize,
		&i.RawResolution,
		&i.RawBitrate,
		&i.DurationMicros,
		&i.EncodedResolution,
		&i.EncodedBitrate,
		&i.ThumbnailUrl,
		&i.HlsMasterPlaylist,
		&i.Difficulty,
		&i.Summary,
		&i.Tags,
		&i.VisibilityStatus,
		&i.PublishAt,
		&i.RawSubtitleUrl,
		&i.ErrorMessage,
	)
	return i, err
}

const getVideoMetadata = `-- name: GetVideoMetadata :one
SELECT
    video_id,
    status,
    media_status,
    analysis_status,
    duration_micros,
    encoded_resolution,
    encoded_bitrate,
    thumbnail_url,
    hls_master_playlist,
    difficulty,
    summary,
    tags,
    visibility_status,
    publish_at,
    raw_subtitle_url,
    updated_at,
    version
FROM catalog.videos
WHERE video_id = $1
`

type GetVideoMetadataRow struct {
	VideoID           uuid.UUID          `json:"video_id"`
	Status            po.VideoStatus     `json:"status"`
	MediaStatus       po.StageStatus     `json:"media_status"`
	AnalysisStatus    po.StageStatus     `json:"analysis_status"`
	DurationMicros    pgtype.Int8        `json:"duration_micros"`
	EncodedResolution pgtype.Text        `json:"encoded_resolution"`
	EncodedBitrate    pgtype.Int4        `json:"encoded_bitrate"`
	ThumbnailUrl      pgtype.Text        `json:"thumbnail_url"`
	HlsMasterPlaylist pgtype.Text        `json:"hls_master_playlist"`
	Difficulty        pgtype.Text        `json:"difficulty"`
	Summary           pgtype.Text        `json:"summary"`
	Tags              []string           `json:"tags"`
	VisibilityStatus  string             `json:"visibility_status"`
	PublishAt         pgtype.Timestamptz `json:"publish_at"`
	RawSubtitleUrl    pgtype.Text        `json:"raw_subtitle_url"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	Version           int64              `json:"version"`
}

func (q *Queries) GetVideoMetadata(ctx context.Context, videoID uuid.UUID) (GetVideoMetadataRow, error) {
	row := q.db.QueryRow(ctx, getVideoMetadata, videoID)
	var i GetVideoMetadataRow
	err := row.Scan(
		&i.VideoID,
		&i.Status,
		&i.MediaStatus,
		&i.AnalysisStatus,
		&i.DurationMicros,
		&i.EncodedResolution,
		&i.EncodedBitrate,
		&i.ThumbnailUrl,
		&i.HlsMasterPlaylist,
		&i.Difficulty,
		&i.Summary,
		&i.Tags,
		&i.VisibilityStatus,
		&i.PublishAt,
		&i.RawSubtitleUrl,
		&i.UpdatedAt,
		&i.Version,
	)
	return i, err
}

const listPublicVideos = `-- name: ListPublicVideos :many
SELECT
    video_id,
    title,
    status,
    media_status,
    analysis_status,
    visibility_status,
    publish_at,
    created_at,
    updated_at
FROM catalog.videos
WHERE status IN ('ready', 'published')
  AND (
        $1 IS NULL
        OR created_at < $1
        OR (created_at = $1 AND video_id < $2)
      )
ORDER BY created_at DESC, video_id DESC
LIMIT $3
`

type ListPublicVideosParams struct {
	CursorCreatedAt interface{} `json:"cursor_created_at"`
	CursorVideoID   pgtype.UUID `json:"cursor_video_id"`
	Limit           int32       `json:"limit"`
}

type ListPublicVideosRow struct {
	VideoID          uuid.UUID          `json:"video_id"`
	Title            string             `json:"title"`
	Status           po.VideoStatus     `json:"status"`
	MediaStatus      po.StageStatus     `json:"media_status"`
	AnalysisStatus   po.StageStatus     `json:"analysis_status"`
	VisibilityStatus string             `json:"visibility_status"`
	PublishAt        pgtype.Timestamptz `json:"publish_at"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) ListPublicVideos(ctx context.Context, arg ListPublicVideosParams) ([]ListPublicVideosRow, error) {
	rows, err := q.db.Query(ctx, listPublicVideos, arg.CursorCreatedAt, arg.CursorVideoID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPublicVideosRow{}
	for rows.Next() {
		var i ListPublicVideosRow
		if err := rows.Scan(
			&i.VideoID,
			&i.Title,
			&i.Status,
			&i.MediaStatus,
			&i.AnalysisStatus,
			&i.VisibilityStatus,
			&i.PublishAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserUploads = `-- name: ListUserUploads :many
SELECT
    video_id,
    title,
    status,
    media_status,
    analysis_status,
    version,
    visibility_status,
    publish_at,
    created_at,
    updated_at
FROM catalog.videos
WHERE upload_user_id = $1
  AND (
        $2 IS NULL
        OR cardinality($2) = 0
        OR status = ANY($2)
      )
  AND (
        $3 IS NULL
        OR cardinality($3) = 0
        OR media_status = ANY($3)
        OR analysis_status = ANY($3)
      )
  AND (
        $4 IS NULL
        OR created_at < $4
        OR (created_at = $4 AND video_id < $5)
      )
ORDER BY created_at DESC, video_id DESC
LIMIT $6
`

type ListUserUploadsParams struct {
	UploadUserID    uuid.UUID   `json:"upload_user_id"`
	StatusFilter    interface{} `json:"status_filter"`
	StageFilter     interface{} `json:"stage_filter"`
	CursorCreatedAt interface{} `json:"cursor_created_at"`
	CursorVideoID   pgtype.UUID `json:"cursor_video_id"`
	Limit           int32       `json:"limit"`
}

type ListUserUploadsRow struct {
	VideoID          uuid.UUID          `json:"video_id"`
	Title            string             `json:"title"`
	Status           po.VideoStatus     `json:"status"`
	MediaStatus      po.StageStatus     `json:"media_status"`
	AnalysisStatus   po.StageStatus     `json:"analysis_status"`
	Version          int64              `json:"version"`
	VisibilityStatus string             `json:"visibility_status"`
	PublishAt        pgtype.Timestamptz `json:"publish_at"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) ListUserUploads(ctx context.Context, arg ListUserUploadsParams) ([]ListUserUploadsRow, error) {
	rows, err := q.db.Query(ctx, listUserUploads,
		arg.UploadUserID,
		arg.StatusFilter,
		arg.StageFilter,
		arg.CursorCreatedAt,
		arg.CursorVideoID,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserUploadsRow{}
	for rows.Next() {
		var i ListUserUploadsRow
		if err := rows.Scan(
			&i.VideoID,
			&i.Title,
			&i.Status,
			&i.MediaStatus,
			&i.AnalysisStatus,
			&i.Version,
			&i.VisibilityStatus,
			&i.PublishAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
