// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: video_projection.sql

package profiledb

import (
	"context"

	uuid "github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const getVideoProjection = `-- name: GetVideoProjection :one
SELECT
    video_id,
    title,
    description,
    duration_micros,
    thumbnail_url,
    hls_master_playlist,
    status,
    visibility_status,
    published_at,
    version,
    updated_at
FROM profile.videos_projection
WHERE video_id = $1
`

func (q *Queries) GetVideoProjection(ctx context.Context, videoID uuid.UUID) (ProfileVideosProjection, error) {
	row := q.db.QueryRow(ctx, getVideoProjection, videoID)
	var i ProfileVideosProjection
	err := row.Scan(
		&i.VideoID,
		&i.Title,
		&i.Description,
		&i.DurationMicros,
		&i.ThumbnailUrl,
		&i.HlsMasterPlaylist,
		&i.Status,
		&i.VisibilityStatus,
		&i.PublishedAt,
		&i.Version,
		&i.UpdatedAt,
	)
	return i, err
}

const listVideoProjections = `-- name: ListVideoProjections :many
SELECT
    video_id,
    title,
    description,
    duration_micros,
    thumbnail_url,
    hls_master_playlist,
    status,
    visibility_status,
    published_at,
    version,
    updated_at
FROM profile.videos_projection
WHERE video_id = ANY($1::uuid[])
`

func (q *Queries) ListVideoProjections(ctx context.Context, dollar_1 []uuid.UUID) ([]ProfileVideosProjection, error) {
	rows, err := q.db.Query(ctx, listVideoProjections, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProfileVideosProjection{}
	for rows.Next() {
		var i ProfileVideosProjection
		if err := rows.Scan(
			&i.VideoID,
			&i.Title,
			&i.Description,
			&i.DurationMicros,
			&i.ThumbnailUrl,
			&i.HlsMasterPlaylist,
			&i.Status,
			&i.VisibilityStatus,
			&i.PublishedAt,
			&i.Version,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertVideoProjection = `-- name: UpsertVideoProjection :exec
INSERT INTO profile.videos_projection (
    video_id,
    title,
    description,
    duration_micros,
    thumbnail_url,
    hls_master_playlist,
    status,
    visibility_status,
    published_at,
    version,
    updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, COALESCE($11, now())
)
ON CONFLICT (video_id) DO UPDATE
SET title               = $2,
    description         = $3,
    duration_micros     = $4,
    thumbnail_url       = $5,
    hls_master_playlist = $6,
    status              = $7,
    visibility_status   = $8,
    published_at        = $9,
    version             = $10,
    updated_at          = COALESCE($11, now())
`

type UpsertVideoProjectionParams struct {
	VideoID           uuid.UUID          `json:"video_id"`
	Title             string             `json:"title"`
	Description       pgtype.Text        `json:"description"`
	DurationMicros    pgtype.Int8        `json:"duration_micros"`
	ThumbnailUrl      pgtype.Text        `json:"thumbnail_url"`
	HlsMasterPlaylist pgtype.Text        `json:"hls_master_playlist"`
	Status            pgtype.Text        `json:"status"`
	VisibilityStatus  pgtype.Text        `json:"visibility_status"`
	PublishedAt       pgtype.Timestamptz `json:"published_at"`
	Version           int64              `json:"version"`
	Column11          interface{}        `json:"column_11"`
}

func (q *Queries) UpsertVideoProjection(ctx context.Context, arg UpsertVideoProjectionParams) error {
	_, err := q.db.Exec(ctx, upsertVideoProjection,
		arg.VideoID,
		arg.Title,
		arg.Description,
		arg.DurationMicros,
		arg.ThumbnailUrl,
		arg.HlsMasterPlaylist,
		arg.Status,
		arg.VisibilityStatus,
		arg.PublishedAt,
		arg.Version,
		arg.Column11,
	)
	return err
}
