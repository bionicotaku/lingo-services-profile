// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: watch_logs.sql

package profiledb

import (
	"context"

	uuid "github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const getWatchLog = `-- name: GetWatchLog :one
SELECT
    user_id,
    video_id,
    position_seconds,
    progress_ratio,
    total_watch_seconds,
    first_watched_at,
    last_watched_at,
    expires_at,
    redacted_at,
    created_at,
    updated_at
FROM profile.watch_logs
WHERE user_id = $1
  AND video_id = $2
`

type GetWatchLogParams struct {
	UserID  uuid.UUID `json:"user_id"`
	VideoID uuid.UUID `json:"video_id"`
}

func (q *Queries) GetWatchLog(ctx context.Context, arg GetWatchLogParams) (ProfileWatchLog, error) {
	row := q.db.QueryRow(ctx, getWatchLog, arg.UserID, arg.VideoID)
	var i ProfileWatchLog
	err := row.Scan(
		&i.UserID,
		&i.VideoID,
		&i.PositionSeconds,
		&i.ProgressRatio,
		&i.TotalWatchSeconds,
		&i.FirstWatchedAt,
		&i.LastWatchedAt,
		&i.ExpiresAt,
		&i.RedactedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listWatchLogsByUser = `-- name: ListWatchLogsByUser :many
SELECT
    user_id,
    video_id,
    position_seconds,
    progress_ratio,
    total_watch_seconds,
    first_watched_at,
    last_watched_at,
    expires_at,
    redacted_at,
    created_at,
    updated_at
FROM profile.watch_logs
WHERE user_id = $1
  AND (redacted_at IS NULL OR $2::boolean = false)
ORDER BY last_watched_at DESC, video_id DESC
LIMIT $3 OFFSET $4
`

type ListWatchLogsByUserParams struct {
	UserID  uuid.UUID `json:"user_id"`
	Column2 bool      `json:"column_2"`
	Limit   int32     `json:"limit"`
	Offset  int32     `json:"offset"`
}

func (q *Queries) ListWatchLogsByUser(ctx context.Context, arg ListWatchLogsByUserParams) ([]ProfileWatchLog, error) {
	rows, err := q.db.Query(ctx, listWatchLogsByUser,
		arg.UserID,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProfileWatchLog{}
	for rows.Next() {
		var i ProfileWatchLog
		if err := rows.Scan(
			&i.UserID,
			&i.VideoID,
			&i.PositionSeconds,
			&i.ProgressRatio,
			&i.TotalWatchSeconds,
			&i.FirstWatchedAt,
			&i.LastWatchedAt,
			&i.ExpiresAt,
			&i.RedactedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertWatchLog = `-- name: UpsertWatchLog :exec
INSERT INTO profile.watch_logs (
    user_id,
    video_id,
    position_seconds,
    progress_ratio,
    total_watch_seconds,
    first_watched_at,
    last_watched_at,
    expires_at,
    redacted_at
) VALUES (
    $1, $2, $3, $4, $5, COALESCE($6, now()), COALESCE($7, now()), $8, $9
)
ON CONFLICT (user_id, video_id) DO UPDATE
SET position_seconds    = $3,
    progress_ratio      = $4,
    total_watch_seconds = profile.watch_logs.total_watch_seconds + $10,
    last_watched_at     = COALESCE($7, now()),
    expires_at          = $8,
    redacted_at         = $9,
    updated_at          = now()
`

type UpsertWatchLogParams struct {
	UserID              uuid.UUID          `json:"user_id"`
	VideoID             uuid.UUID          `json:"video_id"`
	PositionSeconds     pgtype.Numeric     `json:"position_seconds"`
	ProgressRatio       pgtype.Numeric     `json:"progress_ratio"`
	TotalWatchSeconds   pgtype.Numeric     `json:"total_watch_seconds"`
	Column6             interface{}        `json:"column_6"`
	Column7             interface{}        `json:"column_7"`
	ExpiresAt           pgtype.Timestamptz `json:"expires_at"`
	RedactedAt          pgtype.Timestamptz `json:"redacted_at"`
	TotalWatchSeconds_2 pgtype.Numeric     `json:"total_watch_seconds_2"`
}

func (q *Queries) UpsertWatchLog(ctx context.Context, arg UpsertWatchLogParams) error {
	_, err := q.db.Exec(ctx, upsertWatchLog,
		arg.UserID,
		arg.VideoID,
		arg.PositionSeconds,
		arg.ProgressRatio,
		arg.TotalWatchSeconds,
		arg.Column6,
		arg.Column7,
		arg.ExpiresAt,
		arg.RedactedAt,
		arg.TotalWatchSeconds_2,
	)
	return err
}
